You'll learn:

- Why and how to use suspending functions to perform network requests.

- How to send requests concurrently using coroutines.

- How to share information between different coroutines using channels.

# Methods for fetching datas
## BLOCKING
![image](https://github.com/x1111101101/TIL/assets/97117787/76d226ea-9fec-4d22-9a0f-0fd814a51e28)
(https://kotlinlang.org/docs/coroutines-and-channels.html#blocking-requests)

## CALLBACK
### Use a Background Thread
![image](https://github.com/x1111101101/TIL/assets/97117787/91af25a8-6b1e-432e-981b-095cc5646253)
(https://kotlinlang.org/docs/coroutines-and-channels.html#blocking-requests)

### Use the Retrofit callback API﻿
![image](https://github.com/x1111101101/TIL/assets/97117787/f75c35d4-4c14-41a5-a42d-c752d3c49c23)
(https://kotlinlang.org/docs/coroutines-and-channels.html#blocking-requests)

## Coroutines﻿
![image](https://github.com/x1111101101/TIL/assets/97117787/baecc466-71f7-4894-a21c-bf7f32bff385)
(https://kotlinlang.org/docs/coroutines-and-channels.html#blocking-requests)
- -Dkotlinx.coroutines.debug

## Concurrency﻿
- Deferred
- Job
- await()
- runBlocking() works as an adaptor for starting the top-level main coroutine. It is intended primarily to be used in main() functions and tests.
![image](https://github.com/x1111101101/TIL/assets/97117787/0f83aa4b-278f-4863-90eb-15da8f861e30)
(https://kotlinlang.org/docs/coroutines-and-channels.html#task-5)
``` kotlin
suspend fun loadContributorsConcurrent(service: GitHubService, req: RequestData): List<User> = coroutineScope {
    val repos = service.getOrgRepos(req.org)
        .also { logRepos(req, it) }
        .bodyList()
    val contributors = repos.map { repo->
        async {
            service.getRepoContributors(req.org, repo.name)
                .also { logUsers(repo, it) }
                .bodyList()
        }
    }
    contributors.awaitAll().flatten().aggregate()
}
```
