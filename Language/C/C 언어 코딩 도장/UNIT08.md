# 실수 자료형 사용하기

|자료형|크기(byte)|유효자릿수|비고|
|---|---|---|---|
|float|4|7|IEEE 754 단정밀도 부동 소수점|
|double|8|16|IEEE 754 배정밀도 부동 소수점|
|long double|운영체제마다 다름||

## long double
은 운영체제마다 크기가 다르다.  
윈도우: 8바이트 배정밀도 부동소수점  
linux 32비트: 12바이트  
linux 64비트, OSX 32 및 64비트: 16바이트 4배정도 부동소수점

## 부동 소수점 규약
부동 소수점 규약은 IEEE754 라는 표준으로 정해져 있다.  
적은 비트에 광범위한 실수를 담기 위해 순수하게 정수형 처럼 값을 담는게 아니라 **가수*2^지수**로 실수를 표현할 때 비트의 가수부 영역에 가수 값을, 지수부 영역에 지수 값을 담음으로써 실수를 저장한다.  
그리고 맨 첫번째 비트에는 부호 정보가 저장된다.  

크게 단정밀도, 배정밀도로 나뉘는데, 지수부 가수부를 담는 비트 영역의 크기의 차이에 따라 구분되며, 정확도와 유효 자릿수가 다르다.

이 방법으로 적은 저장공간에 광범위한 실수를 담을 수는 있게 되었지만, 완벽하게 정확히 수를 표현할 수는 없고 근사한 값을 얻게 된다.
-----
double, float을 출력할 땐 %f, long double을 출력할 땐 %LF 서식지정자를 사용한다. 


## 지수표기법
지수표기법을 사용해서 실수를 표현할 때도 l(long double), f(float) 등을 맨 뒤에 붙여서 자료의 크기를 정의해준다.

예: 
- 3.1e5f
- 3.22e7l

### 출력
지수 표기법으로 출력하기  
%e: double, float  
%le: long double

## 최댓/최솟갓
실수형 자료형의 범위는 <float.h> 파일을 이용해서 알 수 있다. 단 이 헤더파일에서 제공하는 범위는 양수에 한한 범위다. (양수 최댓값, 양수 최솟값)
예: FLT_MIN, DBL_MAX, LDBL_MIN  

## 실수의 오버/언더플로우
C에서 실수를 10000000000000와 같이 큰 수로 나누면 언더플로우가 발생하면서 0 또는 쓰레기 값이 된다. 정수형 처럼 최댓값부터 다시 빼지지가 않는다.

그리고 실수의 오버플로우 역시 정수의 오버플로우와 다른데, 실수에 큰 값을 곱하면, 오버플로우가 발생해 무한(inf)이 된다. 음수 실수에 큰 값을 곱하면 -inf가 된다.

실습 코드: https://github.com/x1111101101/CodingDoJang-C/blob/main/unit8.c

## 단항 연산자
```
int min = -2147483648;
```
위 코드를 컴파일 하면 컴파일 에러가 발생한다. int의 최댓값은 2147483647인데, -는 음수로 만드는 단항연산자이므로 -가 붙기 전 2147483648은 이미 int 최댓값을 넘어섰고 자동으로 unsigned int로 판단되고, unsigned int를 음수로 변환하려했기 때문에 에러가 발생한다.

## signed 정수의 오버플로우
unsigned 정수의 오버플로우는 C 표준에 (할당한 수%2^자료형의 비트 수)가 되도록, 즉 0부터 다시 시작하도록 정의되어있으나, signed 정수형은 오버플로우 시 처리 방식을 
컴파일러 개발사가 결정하게 된다. 즉 signed 정수형의 오버플로우는 컴파일러마다  수 있다.

## OS 마다 자료형 크기가 다른 이유?
컴파일러를 만드는 단체마다 자료형의 크기를 독자적으로 정했기 때문이다.
long의 경우 마이크로소프트는 LLP64/IL32P64를 따르지만, 오픈소스 진영과 애플은 LP64/IL32P64를 따른다.

## stdint.h의 추가적인 자료형들
int_fast16_t, int_least16_t 등

## 랭크
int, double, long double 등의 자료형을 크기별로 구분한 것을 랭크(rank)라고 한다. 랭크끼리 섞어 계산하면 높은 랭크가 우선하고, 계산도 상위랭크, 결과도 상위 랭크 자료형으로 된다.  상위 랭크로 하위 랭크 자료형을 모두 포함할 수 있기 때문이다. signed, unsigned를 섞어서 계산하면 unsigned가 우선한다.

상위 랭크 자료형이 하위 랭크 자료형을 모두 포함할 수 없다면 상위 랭크의 unsigned 버전이 사용된다.

