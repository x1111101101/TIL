#include <stdio.h>

/**
Insertion Sort
인덱스를 차례대로 순회하면서 이전 인덱스들 중 하나에 현재 인덱스 값을 넣으면서 이전 인덱스까지의 집합이 오름차순이 되게 만듬
이전 인덱스들은 오름차순 정렬이 되어있다고 가정 -> 필요한 만큼만 비교하므로 버블, 선택 정렬보다 효율적 
*/


/*
{1,4,3,2,5,7,6,9,8,10}를 오름차순으로 정렬하라 

배열(비교 횟수): 
1 4 (1)
1 3 4 (2)
1 2 3 4 (3)
1 2 3 4 5 (1)
1 2 3 4 5 7 (1)
1 2 3 4 5 6 7 (2)
1 2 3 4 5 6 7 9 (1)
1 2 3 4 5 6 7 8 9 (2)
1 2 3 4 5 6 7 8 9 10 (1)

*/
int main(void) {
	int arr[] = {1,4,3,2,5,7,6,9,8,10};
	int i, k, temp;
	for(i = 0; i<9; i++) {
		k = i;
		while(arr[k] > arr[k+1]) {
			temp = arr[k+1];
			arr[k+1] = arr[k];
			arr[k] = temp;
			k -= 1;
		}
	}
	for(i = 0; i<10; i++)
		printf("%d ", arr[i]);
}

/**
비교 횟수가 
최악의 경우에는 1, 2, 3 ... 10(55번)으로, 버블정렬과 다를게 없지만
앞쪽 인덱스들은 항상 오름차순 정렬이 되어있기 때문에 1, 2, 3, 1, 1, 2, 1, 2, 1회(윗쪽 주석의 괄호 참고)와 같이 데이터에 따라 연산 횟수가 그 이하가 될 수 있다.
  
worst data: O(N^2)
best data(2,3,4,5,6,7,8,9,10,1): O(N)
*/
